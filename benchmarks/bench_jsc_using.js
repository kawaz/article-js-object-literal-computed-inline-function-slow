// Direct verification of using syntax behavior in JSC (Bun)

console.log("=== JSC (Bun) using syntax detailed verification ===\n");

const SYM = Symbol.dispose;

class Lock {
  [SYM]() {}
}

function createLiteral() {
  return { [SYM]() {} };
}

const N = 100000;

// ========================================
// using vs try-finally vs simple
// ========================================

function benchUsingLiteral() {
  const start = performance.now();
  for (let i = 0; i < N; i++) {
    using obj = createLiteral();
  }
  return performance.now() - start;
}

function benchUsingClass() {
  const start = performance.now();
  for (let i = 0; i < N; i++) {
    using obj = new Lock();
  }
  return performance.now() - start;
}

function benchTryFinallyLiteral() {
  const start = performance.now();
  for (let i = 0; i < N; i++) {
    const obj = createLiteral();
    try {} finally { obj[SYM](); }
  }
  return performance.now() - start;
}

function benchTryFinallyClass() {
  const start = performance.now();
  for (let i = 0; i < N; i++) {
    const obj = new Lock();
    try {} finally { obj[SYM](); }
  }
  return performance.now() - start;
}

function benchSimpleLiteral() {
  const start = performance.now();
  for (let i = 0; i < N; i++) {
    const obj = createLiteral();
    obj[SYM]();
  }
  return performance.now() - start;
}

function benchSimpleClass() {
  const start = performance.now();
  for (let i = 0; i < N; i++) {
    const obj = new Lock();
    obj[SYM]();
  }
  return performance.now() - start;
}

// Warmup
for (let i = 0; i < 3; i++) {
  benchUsingLiteral();
  benchUsingClass();
  benchTryFinallyLiteral();
  benchTryFinallyClass();
  benchSimpleLiteral();
  benchSimpleClass();
}

// Format with appropriate unit (ms or μs)
function fmt(ms) {
  if (ms < 1) {
    const us = ms * 1000;
    return `${us.toFixed(1)}μs`;
  }
  return `${ms.toFixed(2)}ms`;
}

console.log("[literal (computed + method)]");
console.log(`  using:       ${fmt(benchUsingLiteral())}`);
console.log(`  try-finally: ${fmt(benchTryFinallyLiteral())}`);
console.log(`  simple:      ${fmt(benchSimpleLiteral())}`);

console.log("\n[class]");
console.log(`  using:       ${fmt(benchUsingClass())}`);
console.log(`  try-finally: ${fmt(benchTryFinallyClass())}`);
console.log(`  simple:      ${fmt(benchSimpleClass())}`);


// Multiple runs
console.log("\n\n=== Multiple runs (5 times) ===\n");

console.log("class + using:");
for (let run = 0; run < 5; run++) {
  console.log(`  Run ${run + 1}: ${fmt(benchUsingClass())}`);
}

console.log("\nclass + try-finally:");
for (let run = 0; run < 5; run++) {
  console.log(`  Run ${run + 1}: ${fmt(benchTryFinallyClass())}`);
}

console.log("\nclass + simple:");
for (let run = 0; run < 5; run++) {
  console.log(`  Run ${run + 1}: ${fmt(benchSimpleClass())}`);
}

console.log("\nliteral + using:");
for (let run = 0; run < 5; run++) {
  console.log(`  Run ${run + 1}: ${fmt(benchUsingLiteral())}`);
}

// ========================================
// Exploring using implementation details
// ========================================

console.log("\n\n=== Exploring using implementation details ===\n");

// Check behavior of code generated by using
let disposeCount = 0;
let disposeOrder = [];

class TrackedLock {
  constructor(id) {
    this.id = id;
  }
  [SYM]() {
    disposeCount++;
    disposeOrder.push(this.id);
  }
}

{
  using a = new TrackedLock('a');
  using b = new TrackedLock('b');
  using c = new TrackedLock('c');
}

console.log(`Dispose count: ${disposeCount}`);
console.log(`Dispose order: ${disposeOrder.join(' -> ')}`);
console.log("(Expected: c -> b -> a, LIFO order)");

// Handling of null/undefined
disposeCount = 0;
try {
  using x = null;
  using y = undefined;
  console.log("\nnull/undefined are not disposed (normal)");
} catch (e) {
  console.log(`\nnull/undefined error: ${e.message}`);
}
console.log(`Dispose count after null/undefined: ${disposeCount}`);
